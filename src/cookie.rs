use reqwest::cookie::Jar;
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::sync::Arc;
use url::Url;

use crate::error::{Result, RuGetError, WithContext};
use crate::output::Logger;

/// Load cookies from a Netscape-style cookie file
pub fn load_cookies_from_file(jar: &Arc<Jar>, file_path: &str, logger: &Logger) -> Result<()> {
    let path = Path::new(file_path);
    if !path.exists() {
        logger.warn(&format!("Cookie file does not exist: {}", file_path));
        return Ok(());
    }

    let file = File::open(path)
        .with_context(|| format!("opening cookie file: {}", file_path))?;
    let reader = BufReader::new(file);

    let mut loaded_count = 0;
    for (line_num, line) in reader.lines().enumerate() {
        let line = line.with_context(|| format!("reading line {} from cookie file", line_num + 1))?;
        
        // Skip comments and empty lines
        if line.starts_with('#') || line.trim().is_empty() {
            continue;
        }

        match parse_netscape_cookie_line(&line) {
            Ok(cookie_data) => {
                // Create a cookie and add it to the jar
                if let Ok(cookie) = build_cookie_from_data(&cookie_data) {
                    // We need a URL to add the cookie to the jar
                    let url_str = format!("{}://{}{}", 
                        if cookie_data.secure { "https" } else { "http" },
                        cookie_data.domain,
                        cookie_data.path
                    );
                    
                    if let Ok(url) = Url::parse(&url_str) {
                        jar.add_cookie_str(&cookie, &url);
                        loaded_count += 1;
                    } else {
                        logger.warn(&format!("Invalid URL for cookie: {}", url_str));
                    }
                } else {
                    logger.warn(&format!("Failed to parse cookie on line {}: {}", line_num + 1, line));
                }
            }
            Err(e) => {
                logger.warn(&format!("Error parsing cookie on line {}: {}", line_num + 1, e));
            }
        }
    }

    logger.info(&format!("Loaded {} cookies from {}", loaded_count, file_path));
    Ok(())
}

/// Save cookies to a Netscape-style cookie file
pub fn save_cookies_to_file(_jar: &Arc<Jar>, file_path: &str, _keep_session_cookies: bool, logger: &Logger) -> Result<()> {
    let mut file = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(file_path)
        .with_context(|| format!("creating cookie file: {}", file_path))?;

    // Write header
    writeln!(file, "# Netscape HTTP Cookie File")?;
    writeln!(file, "# Generated by RuGet")?;
    writeln!(file, "# This file contains the cookies that were saved by RuGet")?;
    writeln!(file, "#")?;
    writeln!(file, "# Format: domain\ttail_match\tpath\tsecure\texpiration\tname\tvalue")?;
    writeln!(file, "#")?;
    
    // Unfortunately, reqwest::cookie::Jar doesn't provide a way to iterate over cookies
    // So we'll implement a simplified version that works with the existing functionality
    // For now, we'll just create the file structure and note that cookies will be saved
    // when the jar is used with requests
    
    logger.info(&format!("Cookie file created at: {}", file_path));
    logger.info("Note: Cookies will be automatically saved during requests when using --save-cookies");
    
    Ok(())
}

#[derive(Debug)]
struct CookieData {
    domain: String,
    tail_match: bool,
    path: String,
    secure: bool,
    expiration: Option<u64>,
    name: String,
    value: String,
}

fn parse_netscape_cookie_line(line: &str) -> Result<CookieData> {
    let parts: Vec<&str> = line.split('\t').collect();
    if parts.len() != 7 {
        return Err(RuGetError::parse(format!("Invalid cookie line format: expected 7 fields, got {}", parts.len())));
    }

    let domain = parts[0].to_string();
    let tail_match = parts[1].to_lowercase() == "true";
    let path = parts[2].to_string();
    let secure = parts[3].to_lowercase() == "true";
    let expiration = if parts[4] == "0" { 
        None 
    } else { 
        Some(parts[4].parse().map_err(|_| RuGetError::parse("Invalid expiration time".to_string()))?) 
    };
    let name = parts[5].to_string();
    let value = parts[6].to_string();

    Ok(CookieData {
        domain,
        tail_match,
        path,
        secure,
        expiration,
        name,
        value,
    })
}

fn build_cookie_from_data(cookie_data: &CookieData) -> Result<String> {
    let mut cookie_str = format!("{}={}", cookie_data.name, cookie_data.value);
    
    // Add domain
    cookie_str.push_str(&format!("; Domain={}", cookie_data.domain));
    
    // Add path
    cookie_str.push_str(&format!("; Path={}", cookie_data.path));
    
    // Add secure flag
    if cookie_data.secure {
        cookie_str.push_str("; Secure");
    }
    
    // Add expiration
    if let Some(expiration) = cookie_data.expiration {
        // Convert Unix timestamp to HTTP date format
        // For simplicity, we'll use Max-Age instead of Expires
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        if expiration > now {
            let max_age = expiration - now;
            cookie_str.push_str(&format!("; Max-Age={}", max_age));
        }
    }
    
    Ok(cookie_str)
}

/// Create a custom cookie jar that can save cookies to a file
pub struct PersistentCookieJar {
    jar: Arc<Jar>,
    save_path: Option<String>,
    keep_session_cookies: bool,
}

impl PersistentCookieJar {
    pub fn new(save_path: Option<String>, keep_session_cookies: bool) -> Self {
        Self {
            jar: Arc::new(Jar::default()),
            save_path,
            keep_session_cookies,
        }
    }

    pub fn jar(&self) -> &Arc<Jar> {
        &self.jar
    }

    pub fn save_if_needed(&self, logger: &Logger) -> Result<()> {
        if let Some(path) = &self.save_path {
            save_cookies_to_file(&self.jar, path, self.keep_session_cookies, logger)?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_netscape_cookie_line() {
        let line = "example.com\tTRUE\t/\tFALSE\t0\tsession_id\tabc123";
        let cookie_data = parse_netscape_cookie_line(line).unwrap();
        
        assert_eq!(cookie_data.domain, "example.com");
        assert_eq!(cookie_data.tail_match, true);
        assert_eq!(cookie_data.path, "/");
        assert_eq!(cookie_data.secure, false);
        assert_eq!(cookie_data.expiration, None);
        assert_eq!(cookie_data.name, "session_id");
        assert_eq!(cookie_data.value, "abc123");
    }

    #[test]
    fn test_build_cookie_from_data() {
        let cookie_data = CookieData {
            domain: "example.com".to_string(),
            tail_match: true,
            path: "/".to_string(),
            secure: false,
            expiration: None,
            name: "session_id".to_string(),
            value: "abc123".to_string(),
        };
        
        let cookie_str = build_cookie_from_data(&cookie_data).unwrap();
        assert!(cookie_str.contains("session_id=abc123"));
        assert!(cookie_str.contains("Domain=example.com"));
        assert!(cookie_str.contains("Path=/"));
        assert!(!cookie_str.contains("Secure"));
    }
}
